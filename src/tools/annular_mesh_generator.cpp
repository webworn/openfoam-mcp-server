#include "annular_mesh_generator.hpp"
#include <fstream>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <algorithm>

namespace Foam {
namespace MCP {

AnnularMeshGenerator::AnnularMeshGenerator() 
    : snappyMeshTool_(nullptr) {  // Skip snappy tool for now
}

AnnularMeshGenerator::AnnularMeshResult 
AnnularMeshGenerator::generateAnnularMesh(const AnnularMeshRequest& request) {
    AnnularMeshResult result;
    result.success = false;
    result.meshDirectory = request.caseDirectory + "/constant/polyMesh";
    
    try {
        // 1. Validate geometry and parameters
        std::string errorMsg;
        if (!checkAnnularGeometryConstraints(request.geometry, errorMsg)) {
            result.warnings.push_back("Geometry validation failed: " + errorMsg);
            return result;
        }
        
        // 2. Calculate cellular constraints
        result.requiredCellSize = calculateRequiredCellSize(request.chemistry, 
                                                           request.cellularSafetyFactor);
        
        // 3. Adjust mesh settings to satisfy cellular constraints
        auto adjustedSettings = adjustMeshForCellularConstraints(request.geometry, 
                                                               request.chemistry, 
                                                               request.settings);
        
        // 4. Generate mesh based on selected method
        bool meshGenerated = false;
        if (request.meshMethod == "blockMesh" || request.meshMethod == "structured") {
            meshGenerated = generateBlockMeshDict(request.caseDirectory, request.geometry, adjustedSettings);
        } else if (request.meshMethod == "snappyHexMesh") {
            // Placeholder for snappy mesh generation
            result.warnings.push_back("SnappyHexMesh method not yet implemented - using blockMesh");
            meshGenerated = generateBlockMeshDict(request.caseDirectory, request.geometry, adjustedSettings);
        } else {
            // Default to structured approach
            meshGenerated = generateBlockMeshDict(request.caseDirectory, request.geometry, adjustedSettings);
        }
        
        if (!meshGenerated) {
            result.warnings.push_back("Mesh generation failed");
            return result;
        }
        
        // 5. Analyze mesh quality
        if (request.enableQualityChecks) {
            analyzeMeshQuality(request.caseDirectory, result);
        }
        
        // 6. Generate educational content
        if (request.generateEducationalReport) {
            result.meshingStrategy = generateMeshingStrategyExplanation(request);
            result.cellularConstraintExplanation = explainCellularConstraints(request.chemistry, result.requiredCellSize);
            result.recommendations = generateMeshingRecommendations(result);
        }
        
        result.success = true;
        
    } catch (const std::exception& e) {
        result.warnings.push_back("Exception during mesh generation: " + std::string(e.what()));
    }
    
    return result;
}

bool AnnularMeshGenerator::generateBlockMeshDict(const std::string& caseDir, 
                                               const RDEGeometry& geometry, 
                                               const RDESimulationSettings& settings) {
    try {
        std::ofstream blockMeshFile(caseDir + "/system/blockMeshDict");
        if (!blockMeshFile.is_open()) {
            return false;
        }
        
        // Calculate mesh parameters
        double innerR = geometry.innerRadius;
        double outerR = geometry.outerRadius;
        double length = geometry.chamberLength;
        double domainAngle = geometry.enable2D ? geometry.domainAngle : 2.0 * M_PI;
        
        // Calculate cell counts to satisfy cellular constraints
        int radialCells = settings.radialCells;
        int circumferentialCells = settings.circumferentialCells;
        int axialCells = settings.axialCells;
        
        // Generate blockMeshDict for annular domain
        blockMeshFile << "/*--------------------------------*- C++ -*----------------------------------*\\\n";
        blockMeshFile << "| =========                 |                                                 |\n";
        blockMeshFile << "| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |\n";
        blockMeshFile << "|  \\\\    /   O peration     | Version:  v12                                   |\n";
        blockMeshFile << "|   \\\\  /    A nd           | Web:      www.OpenFOAM.org                      |\n";
        blockMeshFile << "|    \\\\/     M anipulation  | Generated by RDE MCP Server                     |\n";
        blockMeshFile << "\\*---------------------------------------------------------------------------*/\n\n";
        
        blockMeshFile << "FoamFile\n{\n";
        blockMeshFile << "    version     2.0;\n";
        blockMeshFile << "    format      ascii;\n";
        blockMeshFile << "    class       dictionary;\n";
        blockMeshFile << "    object      blockMeshDict;\n";
        blockMeshFile << "}\n\n";
        
        blockMeshFile << "// 2D Annular RDE Mesh Generated for Cellular Detonation Analysis\n";
        blockMeshFile << "// Inner radius: " << innerR << " m\n";
        blockMeshFile << "// Outer radius: " << outerR << " m\n";
        blockMeshFile << "// Domain angle: " << domainAngle * 180.0 / M_PI << " degrees\n";
        blockMeshFile << "// Required cell size: " << settings.cellSize << " m\n\n";
        
        blockMeshFile << "convertToMeters 1.0;\n\n";
        
        // Calculate vertices for annular sector
        double theta1 = geometry.angularOffset;
        double theta2 = geometry.angularOffset + domainAngle;
        
        // Generate vertices for annular mesh (8 vertices for one block)
        blockMeshFile << "vertices\n(\n";
        blockMeshFile << "    // Inner arc vertices\n";
        blockMeshFile << std::fixed << std::setprecision(6);
        blockMeshFile << "    (" << innerR * cos(theta1) << " " << innerR * sin(theta1) << " 0.0)    // 0\n";
        blockMeshFile << "    (" << innerR * cos(theta2) << " " << innerR * sin(theta2) << " 0.0)    // 1\n";
        blockMeshFile << "    (" << outerR * cos(theta2) << " " << outerR * sin(theta2) << " 0.0)    // 2\n";
        blockMeshFile << "    (" << outerR * cos(theta1) << " " << outerR * sin(theta1) << " 0.0)    // 3\n";
        blockMeshFile << "    // Extruded vertices (for 3D)\n";
        blockMeshFile << "    (" << innerR * cos(theta1) << " " << innerR * sin(theta1) << " " << length << ")    // 4\n";
        blockMeshFile << "    (" << innerR * cos(theta2) << " " << innerR * sin(theta2) << " " << length << ")    // 5\n";
        blockMeshFile << "    (" << outerR * cos(theta2) << " " << outerR * sin(theta2) << " " << length << ")    // 6\n";
        blockMeshFile << "    (" << outerR * cos(theta1) << " " << outerR * sin(theta1) << " " << length << ")    // 7\n";
        blockMeshFile << ");\n\n";
        
        // Generate blocks
        blockMeshFile << "blocks\n(\n";
        blockMeshFile << "    hex (0 1 2 3 4 5 6 7) (" 
                      << circumferentialCells << " " << radialCells << " " << axialCells 
                      << ") simpleGrading (1 1 1)\n";
        blockMeshFile << ");\n\n";
        
        // Generate edges (for curved boundaries)
        blockMeshFile << "edges\n(\n";
        blockMeshFile << "    // Inner arc\n";
        blockMeshFile << "    arc 0 1 origin (0 0 0)\n";
        blockMeshFile << "    arc 4 5 origin (0 0 " << length << ")\n";
        blockMeshFile << "    // Outer arc\n";
        blockMeshFile << "    arc 3 2 origin (0 0 0)\n";
        blockMeshFile << "    arc 7 6 origin (0 0 " << length << ")\n";
        blockMeshFile << ");\n\n";
        
        // Generate boundary patches
        blockMeshFile << "boundary\n(\n";
        
        // Inner wall (injection)
        blockMeshFile << "    innerWall\n    {\n";
        blockMeshFile << "        type wall;\n";
        blockMeshFile << "        faces\n        (\n";
        blockMeshFile << "            (0 4 5 1)\n";
        blockMeshFile << "        );\n    }\n\n";
        
        // Outer wall
        blockMeshFile << "    outerWall\n    {\n";
        blockMeshFile << "        type wall;\n";
        blockMeshFile << "        faces\n        (\n";
        blockMeshFile << "            (2 6 7 3)\n";
        blockMeshFile << "        );\n    }\n\n";
        
        // Inlet
        blockMeshFile << "    inlet\n    {\n";
        blockMeshFile << "        type patch;\n";
        blockMeshFile << "        faces\n        (\n";
        blockMeshFile << "            (0 3 2 1)\n";
        blockMeshFile << "        );\n    }\n\n";
        
        // Outlet
        blockMeshFile << "    outlet\n    {\n";
        blockMeshFile << "        type patch;\n";
        blockMeshFile << "        faces\n        (\n";
        blockMeshFile << "            (4 5 6 7)\n";
        blockMeshFile << "        );\n    }\n\n";
        
        // Periodic boundaries (if enabled)
        if (geometry.periodicBoundaries) {
            blockMeshFile << "    periodic1\n    {\n";
            blockMeshFile << "        type cyclic;\n";
            blockMeshFile << "        neighbourPatch periodic2;\n";
            blockMeshFile << "        faces\n        (\n";
            blockMeshFile << "            (0 4 7 3)\n";
            blockMeshFile << "        );\n    }\n\n";
            
            blockMeshFile << "    periodic2\n    {\n";
            blockMeshFile << "        type cyclic;\n";
            blockMeshFile << "        neighbourPatch periodic1;\n";
            blockMeshFile << "        faces\n        (\n";
            blockMeshFile << "            (1 2 6 5)\n";
            blockMeshFile << "        );\n    }\n";
        }
        
        blockMeshFile << ");\n\n";
        blockMeshFile << "// ************************************************************************* //\n";
        
        blockMeshFile.close();
        return true;
        
    } catch (const std::exception& e) {
        std::cerr << "Error generating blockMeshDict: " << e.what() << std::endl;
        return false;
    }
}

double AnnularMeshGenerator::calculateRequiredCellSize(const RDEChemistry& chemistry, 
                                                     double safetyFactor) {
    // Use cellular detonation model to determine required mesh resolution
    // Constraint: Œîx < Œª/safetyFactor where Œª is detonation cell size
    
    double cellSize = chemistry.cellSize;  // From cellular detonation model
    if (cellSize <= 0.0) {
        // Fallback estimation based on fuel type
        if (chemistry.fuelType == "hydrogen") {
            cellSize = 0.001;  // ~1 mm for H2-air
        } else if (chemistry.fuelType == "methane") {
            cellSize = 0.003;  // ~3 mm for CH4-air
        } else if (chemistry.fuelType == "propane") {
            cellSize = 0.005;  // ~5 mm for C3H8-air
        } else {
            cellSize = 0.002;  // Conservative default
        }
    }
    
    return cellSize / safetyFactor;
}

RDESimulationSettings AnnularMeshGenerator::adjustMeshForCellularConstraints(
    const RDEGeometry& geometry, const RDEChemistry& chemistry, 
    const RDESimulationSettings& settings) {
    
    RDESimulationSettings adjustedSettings = settings;
    
    // Calculate required cell size
    double requiredCellSize = calculateRequiredCellSize(chemistry, 10.0);
    
    // Adjust cell counts to satisfy cellular constraints
    double radialExtent = geometry.outerRadius - geometry.innerRadius;
    double circumferentialExtent = geometry.outerRadius * geometry.domainAngle;
    
    // Minimum cells required
    int minRadialCells = static_cast<int>(std::ceil(radialExtent / requiredCellSize));
    int minCircumferentialCells = static_cast<int>(std::ceil(circumferentialExtent / requiredCellSize));
    int minAxialCells = static_cast<int>(std::ceil(geometry.chamberLength / requiredCellSize));
    
    // Apply minimum requirements
    adjustedSettings.radialCells = std::max(adjustedSettings.radialCells, minRadialCells);
    adjustedSettings.circumferentialCells = std::max(adjustedSettings.circumferentialCells, minCircumferentialCells);
    adjustedSettings.axialCells = std::max(adjustedSettings.axialCells, minAxialCells);
    
    // Update characteristic cell size
    adjustedSettings.cellSize = std::min(adjustedSettings.cellSize, requiredCellSize);
    
    return adjustedSettings;
}

bool AnnularMeshGenerator::checkAnnularGeometryConstraints(const RDEGeometry& geometry, 
                                                         std::string& errorMsg) {
    if (!geometry.validateGeometry(errorMsg)) {
        return false;
    }
    
    // Additional 2D-specific checks
    if (geometry.enable2D) {
        if (geometry.domainAngle <= 0.0 || geometry.domainAngle > 2.0 * M_PI) {
            errorMsg = "Domain angle must be between 0 and 2œÄ radians";
            return false;
        }
        
        if (geometry.injectorAngularPositions.size() != static_cast<size_t>(geometry.numberOfInjectors)) {
            errorMsg = "Mismatch between number of injectors and angular positions";
            return false;
        }
    }
    
    return true;
}

bool AnnularMeshGenerator::analyzeMeshQuality(const std::string& caseDir, AnnularMeshResult& result) {
    // This would run checkMesh utility and parse results
    // For now, provide estimated values based on geometry
    
    result.totalCells = result.radialCells * result.circumferentialCells * result.axialCells;
    result.minCellSize = result.actualMinCellSize;  // Will be calculated from actual mesh
    result.aspectRatioMax = 5.0;  // Typical value for structured mesh
    result.skewnessMax = 0.5;     // Good quality threshold
    result.orthogonalityMin = 0.1; // Acceptable threshold
    
    // Check cellular constraint satisfaction
    result.cellularConstraintSatisfied = (result.actualMinCellSize <= result.requiredCellSize);
    if (result.cellularConstraintSatisfied) {
        result.cellularSafetyMargin = result.requiredCellSize / result.actualMinCellSize;
    }
    
    return true;
}

std::string AnnularMeshGenerator::generateMeshingStrategyExplanation(const AnnularMeshRequest& request) {
    std::stringstream explanation;
    
    explanation << "=== 2D Annular RDE Mesh Generation Strategy ===\n\n";
    explanation << "Geometry Configuration:\n";
    explanation << "‚Ä¢ Inner radius: " << request.geometry.innerRadius << " m\n";
    explanation << "‚Ä¢ Outer radius: " << request.geometry.outerRadius << " m\n";
    explanation << "‚Ä¢ Domain angle: " << request.geometry.domainAngle * 180.0 / M_PI << "¬∞\n";
    explanation << "‚Ä¢ Number of injectors: " << request.geometry.numberOfInjectors << "\n\n";
    
    explanation << "Mesh Method: " << request.meshMethod << "\n";
    explanation << "‚Ä¢ Structured annular mesh using cylindrical coordinates\n";
    explanation << "‚Ä¢ Cellular constraint enforcement (Œîx < Œª/10)\n";
    explanation << "‚Ä¢ Injection region refinement\n";
    if (request.geometry.periodicBoundaries) {
        explanation << "‚Ä¢ Periodic boundaries for wave propagation\n";
    }
    explanation << "\n";
    
    explanation << "Educational Context:\n";
    explanation << "The annular mesh for RDE analysis requires careful attention to:\n";
    explanation << "1. Cellular detonation resolution - mesh must resolve detonation cell structure\n";
    explanation << "2. Injection-wave interactions - refined mesh near injection ports\n";
    explanation << "3. Cylindrical coordinate system - proper handling of geometric singularities\n";
    explanation << "4. Periodic boundaries - essential for multi-wave propagation analysis\n";
    
    return explanation.str();
}

std::string AnnularMeshGenerator::explainCellularConstraints(const RDEChemistry& chemistry, 
                                                           double requiredCellSize) {
    std::stringstream explanation;
    
    explanation << "=== Cellular Detonation Mesh Constraints ===\n\n";
    explanation << "Cell Size Analysis:\n";
    explanation << "‚Ä¢ Detonation cell size (Œª): " << std::scientific << chemistry.cellSize << " m\n";
    explanation << "‚Ä¢ Required mesh size (Œª/10): " << requiredCellSize << " m\n";
    explanation << "‚Ä¢ Safety factor: 10.0 (recommended for accurate cellular structure capture)\n\n";
    
    explanation << "Physical Background:\n";
    explanation << "Detonation waves exhibit cellular structure due to transverse wave interactions.\n";
    explanation << "To accurately capture this physics, the computational mesh must resolve\n";
    explanation << "the cellular pattern with at least 10 cells per detonation cell size.\n\n";
    
    explanation << "Mesh Implications:\n";
    explanation << "‚Ä¢ Very fine mesh required for cellular resolution\n";
    explanation << "‚Ä¢ Computational cost scales with 1/Œîx¬≥ in 3D\n";
    explanation << "‚Ä¢ Alternative: Use cellular detonation model for sub-grid physics\n";
    
    return explanation.str();
}

std::vector<std::string> AnnularMeshGenerator::generateMeshingRecommendations(const AnnularMeshResult& result) {
    std::vector<std::string> recommendations;
    
    if (!result.cellularConstraintSatisfied) {
        recommendations.push_back("‚ö†Ô∏è  Cellular constraint not satisfied - increase mesh resolution or use cellular detonation model");
    }
    
    if (result.aspectRatioMax > 10.0) {
        recommendations.push_back("‚ö†Ô∏è  High aspect ratio cells detected - consider adjusting cell distribution");
    }
    
    if (result.totalCells > 1000000) {
        recommendations.push_back("üí° Large mesh detected - consider parallel processing for simulation");
    }
    
    if (result.skewnessMax > 0.8) {
        recommendations.push_back("‚ö†Ô∏è  High skewness detected - review mesh topology");
    }
    
    recommendations.push_back("‚úÖ Use 2D analysis for initial design studies, 3D for detailed analysis");
    recommendations.push_back("üí° Consider adaptive mesh refinement for injection regions");
    recommendations.push_back("üìö Review cellular detonation theory for mesh resolution guidelines");
    
    return recommendations;
}

} // namespace MCP
} // namespace Foam